<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Portfolio Physics Wall - Tight Box Stacking</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #ffffff;
    }
    canvas {
      position: fixed; inset: 0; display: block;
      background: #ffffff; touch-action: none;
      width: 100%; height: 100%; 
    }
    #intro {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      pointer-events: none;
      font-size: 1.05rem; color: #999; text-align: center;
      padding: 0 16px; transition: opacity 0.3s ease;
      z-index: 5; line-height: 1.6;
    }
    #intro.hidden { opacity: 0; }

    /* 상세 모달 스타일 */
    .detail-overlay {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.25);
      opacity: 0; pointer-events: none; transition: opacity 0.25s ease;
      z-index: 10;
    }
    .detail-overlay.open { opacity: 1; pointer-events: auto; }
    .detail-modal {
      width: min(480px, 80vw); max-height: min(70vh, 90vh);
      background: rgba(255,255,255,0.98); border-radius: 16px;
      box-shadow: 0 18px 45px rgba(0,0,0,0.22);
      padding: 20px 18px; display: flex; flex-direction: column; gap: 12px;
      animation: pop-in 0.22s ease-out;
    }
    @keyframes pop-in {
      from { transform: translateY(6px) scale(0.96); opacity: 0; }
      to { transform: translateY(0) scale(1); opacity: 1; }
    }
    .detail-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 8px; }
    .detail-title { font-size: 1.05rem; font-weight: 600; }
    .detail-tag { font-size: 0.8rem; color: #777; margin-top: 4px; }
    .detail-close {
      border: none; background: transparent; font-size: 1.3rem;
      line-height: 1; cursor: pointer; padding: 4px 6px; margin: -4px -4px 0 0;
    }
    .detail-body { font-size: 0.9rem; color: #444; line-height: 1.6; overflow-y: auto; padding-right: 4px; }
    .detail-meta { font-size: 0.78rem; color: #999; margin-top: 4px; }

    @media (max-width: 900px) {
      #intro { font-size: 1.3rem; padding: 0 28px; }
      .detail-modal { width: 94vw; max-height: 80vh; border-radius: 18px; padding: 22px 20px; }
      .detail-title { font-size: 1.35rem; }
      .detail-tag { font-size: 0.95rem; }
      .detail-body { font-size: 1.05rem; }
      .detail-meta { font-size: 0.9rem; }
      .detail-close { font-size: 1.6rem; }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="intro">이미지 로딩 중... 잠시만 기다려주세요.</div>

  <div class="detail-overlay" id="detailOverlay">
    <div class="detail-modal">
      <div class="detail-header">
        <div>
          <div class="detail-title" id="detailTitle"></div>
          <div class="detail-tag" id="detailTag"></div>
        </div>
        <button class="detail-close" id="detailClose">×</button>
      </div>
      <div class="detail-body" id="detailBody"></div>
      <div class="detail-meta" id="detailMeta"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const intro = document.getElementById('intro');
    
    const detailOverlay = document.getElementById('detailOverlay');
    const detailTitle = document.getElementById('detailTitle');
    const detailTag = document.getElementById('detailTag');
    const detailBody = document.getElementById('detailBody');
    const detailMeta = document.getElementById('detailMeta');
    const detailClose = document.getElementById('detailClose');

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', resize);
    resize();

    const isMobile = () => window.innerWidth <= 900;

    const works = [
      { id: 'work-1', title: '작업물 1', tag: 'Graphic', description: '설명', meta: 'Tool', imageSrc: './icon/1.png' },
      { id: 'work-2', title: '작업물 2', tag: 'Web', description: '설명', meta: 'Tool', imageSrc: './icon/2.png' },
      { id: 'work-3', title: '작업물 3', tag: 'Branding', description: '설명', meta: 'Tool', imageSrc: './icon/3.png' },
      { id: 'work-4', title: '작업물 4', tag: 'Editorial', description: '설명', meta: 'Tool', imageSrc: './icon/4.png' },
      { id: 'work-5', title: '작업물 5', tag: 'Motion', description: '설명', meta: 'Tool', imageSrc: './icon/5.png' },
      { id: 'work-6', title: '작업물 6', tag: 'UI/UX', description: '설명', meta: 'Tool', imageSrc: './icon/6.png' },
      { id: 'work-7', title: '작업물 7', tag: '3D', description: '설명', meta: 'Tool', imageSrc: './icon/7.png' },
      { id: 'work-8', title: '작업물 8', tag: 'Graphic', description: '설명', meta: 'Tool', imageSrc: './icon/8.png' },
      { id: 'work-9', title: '작업물 9', tag: 'Web', description: '설명', meta: 'Tool', imageSrc: './icon/9.png' },
      { id: 'work-10', title: '작업물 10', tag: 'Photo', description: '설명', meta: 'Tool', imageSrc: './icon/10.png' },
      { id: 'work-11', title: '작업물 11', tag: 'Drawing', description: '설명', meta: 'Tool', imageSrc: './icon/11.png' },
      { id: 'work-12', title: '작업물 12', tag: 'Package', description: '설명', meta: 'Tool', imageSrc: './icon/12.png' },
      { id: 'work-13', title: '작업물 13', tag: 'Video', description: '설명', meta: 'Tool', imageSrc: './icon/13.png' },
      { id: 'work-14', title: '작업물 14', tag: 'Poster', description: '설명', meta: 'Tool', imageSrc: './icon/14.png' },
      { id: 'work-15', title: '작업물 15', tag: 'Logo', description: '설명', meta: 'Tool', imageSrc: './icon/15.png' }
    ];

    const loadedImages = {};
    let imagesLoadedCount = 0;
    let allImagesLoaded = false;

    function preloadImages(callback) {
      if (works.length === 0) { callback(); return; }
      works.forEach(work => {
        const img = new Image();
        img.onload = () => {
          imagesLoadedCount++;
          if (imagesLoadedCount === works.length) {
            allImagesLoaded = true;
            callback();
          }
        };
        img.onerror = () => {
          console.error(`이미지 로드 실패: ${work.imageSrc}`);
          imagesLoadedCount++;
          if (imagesLoadedCount === works.length) {
            allImagesLoaded = true;
            callback();
          }
        };
        img.src = work.imageSrc;
        loadedImages[work.id] = img;
      });
    }

    // ===== 물리 엔진 (타이트한 박스 모델) =====
    const shapes = [];
    let hasSpawned = false;
    const gravity = 800;
    const damping = 0.6; 
    const friction = 0.96; 
    // [핵심] 충돌 박스 크기 비율 (0.85 = 실제 이미지의 85% 크기만 충돌 판정)
    const HITBOX_RATIO = 0.85; 

    function spawnShapes() {
      if (!allImagesLoaded) return;
      const w = window.innerWidth;
      shapes.length = 0;

      const mobile = isMobile();
      const count = works.length; 
      const baseSize = mobile ? 100 : 120; 

      for (let i = 0; i < count; i++) {
        const work = works[i % works.length];
        const img = loadedImages[work.id];
        
        let width, height;
        if (img && img.naturalWidth) {
            const aspect = img.naturalHeight / img.naturalWidth;
            width = baseSize + (Math.random() - 0.5) * 40;
            height = width * aspect;
        } else {
            width = baseSize;
            height = baseSize;
        }

        const x = width + Math.random() * (w - 2 * width);
        const y = -200 - Math.random() * 500;
        
        shapes.push({
          id: work.id,
          x, y, vx: (Math.random() - 0.5) * 100, vy: 0,
          width, height, // 실제 그리는 크기
          // [핵심] 실제 충돌 계산에 쓰일 조금 더 작은 크기
          hitWidth: width * HITBOX_RATIO,
          hitHeight: height * HITBOX_RATIO,
          image: img,
          work,
          isDragging: false
        });
      }
    }

    function update(dt) {
      const w = window.innerWidth;
      const h = window.innerHeight;

      for (const s of shapes) {
        if (!s.isDragging) {
          s.vy += gravity * dt;
          s.x += s.vx * dt;
          s.y += s.vy * dt;
          s.vx *= friction;
        }
      }

      // 벽 충돌 (힛박스 기준)
      for (const s of shapes) {
        const halfW = s.hitWidth / 2;
        const halfH = s.hitHeight / 2;

        if (s.y + halfH > h) { s.y = h - halfH; if(s.vy > 0) s.vy = -s.vy * damping; }
        if (s.x - halfW < 0) { s.x = halfW; if(s.vx < 0) s.vx = -s.vx * damping; }
        if (s.x + halfW > w) { s.x = w - halfW; if(s.vx > 0) s.vx = -s.vx * damping; }
      }

      // 물체 간 충돌 (AABB - 타이트한 힛박스 기준)
      for (let i = 0; i < shapes.length; i++) {
        for (let j = i + 1; j < shapes.length; j++) {
          const a = shapes[i];
          const b = shapes[j];
          if (a.isDragging || b.isDragging) continue;

          const dx = b.x - a.x;
          const dy = b.y - a.y;
          
          // [핵심] 충돌 계산에는 줄어든 hitWidth/hitHeight 사용
          const combinedHalfW = (a.hitWidth / 2) + (b.hitWidth / 2);
          const combinedHalfH = (a.hitHeight / 2) + (b.hitHeight / 2);

          const overlapX = combinedHalfW - Math.abs(dx);
          const overlapY = combinedHalfH - Math.abs(dy);

          if (overlapX > 0 && overlapY > 0) {
            if (overlapX < overlapY) {
                const normalX = dx > 0 ? 1 : -1;
                a.x -= normalX * overlapX * 0.5;
                b.x += normalX * overlapX * 0.5;
                
                const relVx = b.vx - a.vx;
                if (relVx * normalX < 0) {
                    const impulse = relVx * (1 + damping) * 0.5;
                    a.vx += impulse; b.vx -= impulse;
                }
            } else {
                const normalY = dy > 0 ? 1 : -1;
                a.y -= normalY * overlapY * 0.5;
                b.y += normalY * overlapY * 0.5;

                const relVy = b.vy - a.vy;
                if (relVy * normalY < 0) {
                    const impulse = relVy * (1 + damping) * 0.5;
                    a.vy += impulse; b.vy -= impulse;
                    if (Math.abs(a.vx) < 50 && Math.abs(b.vx) < 50) {
                        a.vx *= 0.9; b.vx *= 0.9;
                    }
                }
            }
          }
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

      for (const s of shapes) {
        // 그림은 원래 크기(width, height)대로 그림
        if (s.image && s.image.complete && s.image.naturalWidth !== 0) {
          ctx.drawImage(
            s.image,
            s.x - s.width / 2,
            s.y - s.height / 2,
            s.width,
            s.height
          );
          
          // [디버깅용] 실제 충돌 박스 확인하고 싶으면 아래 주석 해제
          // ctx.strokeStyle = 'red'; ctx.lineWidth = 2;
          // ctx.strokeRect(s.x - s.hitWidth/2, s.y - s.hitHeight/2, s.hitWidth, s.hitHeight);

        } else {
          ctx.fillStyle = '#ccc';
          ctx.fillRect(s.x - s.width / 2, s.y - s.height / 2, s.width, s.height);
        }
      }
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = Math.min((timestamp - lastTime) / 1000, 0.02); 
      lastTime = timestamp;

      if (shapes.length > 0) {
        update(dt * 0.5);
        update(dt * 0.5);
        draw();
      }
      requestAnimationFrame(loop);
    }

    function onImagesReady() {
      intro.innerHTML = '화면을 탭하면 아이콘들이 떨어집니다.';
      const start = () => {
        if (!hasSpawned) {
          hasSpawned = true;
          intro.classList.add('hidden');
          spawnShapes();
        }
      };
      document.body.addEventListener('click', start, { once: true });
      document.body.addEventListener('touchstart', start, { once: true, passive: true });
      requestAnimationFrame(loop);
    }
    preloadImages(onImagesReady);

    // 모달 및 포인터 이벤트 (이전과 동일하여 생략하지 않고 전체 포함)
    function showDetail(work) {
      detailTitle.textContent = work.title;
      detailTag.textContent = work.tag;
      detailBody.textContent = work.description;
      detailMeta.textContent = work.meta;
      detailOverlay.classList.add('open');
    }
    function hideDetail() { detailOverlay.classList.remove('open'); }
    detailClose.addEventListener('click', hideDetail);
    detailOverlay.addEventListener('click', e => { if(e.target === detailOverlay) hideDetail(); });

    let isPointerDown = false;
    let dragTarget = null;
    let dragOffsetX=0, dragOffsetY=0;
    let lastPointerX=0, lastPointerY=0;
    let pointerDownTime=0;
    let pointerMovedDistSq=0;

    function getShapeAt(x, y) {
      for (let i = shapes.length - 1; i >= 0; i--) {
        const s = shapes[i];
        // 클릭 판정은 실제 보이는 크기 기준
        if (x >= s.x - s.width/2 && x <= s.x + s.width/2 &&
            y >= s.y - s.height/2 && y <= s.y + s.height/2) {
          return s;
        }
      }
      return null;
    }

    function pointerDown(x, y) {
      isPointerDown = true;
      lastPointerX = x; lastPointerY = y;
      pointerDownTime = performance.now();
      pointerMovedDistSq = 0;
      const s = getShapeAt(x, y);
      if (s) {
        dragTarget = s;
        dragOffsetX = x - s.x;
        dragOffsetY = y - s.y;
        s.isDragging = true;
        s.vx = 0; s.vy = 0;
      }
    }

    function pointerMove(x, y) {
      if (!isPointerDown) return;
      const dx = x - lastPointerX; const dy = y - lastPointerY;
      pointerMovedDistSq += dx*dx + dy*dy;
      lastPointerX = x; lastPointerY = y;
      if (dragTarget) {
        dragTarget.x = x - dragOffsetX;
        dragTarget.y = y - dragOffsetY;
        dragTarget.vx = dx * 20; dragTarget.vy = dy * 20;
      }
    }

    function pointerUp(x, y) {
      if (!isPointerDown) return;
      isPointerDown = false;
      const elapsed = performance.now() - pointerDownTime;
      if (dragTarget) dragTarget.isDragging = false;
      let clicked = dragTarget || getShapeAt(x, y);
      if (!dragTarget) clicked = getShapeAt(x, y);
      if (clicked && pointerMovedDistSq < 50 && elapsed < 300) {
        showDetail(clicked.work);
      }
      dragTarget = null;
    }

    ['mousedown','touchstart'].forEach(evt => 
      canvas.addEventListener(evt, e => {
        e.preventDefault();
        const r = canvas.getBoundingClientRect();
        const p = e.touches ? e.touches[0] : e;
        pointerDown(p.clientX - r.left, p.clientY - r.top);
      }, {passive:false})
    );
    ['mousemove','touchmove'].forEach(evt => 
      canvas.addEventListener(evt, e => {
        e.preventDefault();
        const r = canvas.getBoundingClientRect();
        const p = e.touches ? e.touches[0] : e;
        pointerMove(p.clientX - r.left, p.clientY - r.top);
      }, {passive:false})
    );
    ['mouseup','touchend','touchcancel'].forEach(evt => 
      canvas.addEventListener(evt, e => {
        e.preventDefault();
        pointerUp(lastPointerX, lastPointerY);
      }, {passive:false})
    );
  </script>
</body>
</html>
