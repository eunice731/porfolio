<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Portfolio Physics Wall (Mobile + Inertia + Center Modal)</title>
  <style>
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #ffffff;
    }
    canvas {
      position: fixed;
      inset: 0;
      display: block;
      background: #ffffff;
      touch-action: none; /* 모바일에서 기본 스크롤/줌 방지 */
    }

    #intro {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      font-size: 1.1rem;
      color: #999;
      text-align: center;
      padding: 0 16px;
      transition: opacity 0.3s ease;
      z-index: 5;
    }
    #intro.hidden {
      opacity: 0;
    }

    /* 가운데 모달용 오버레이 */
    .detail-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.25);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      z-index: 10;
    }
    .detail-overlay.open {
      opacity: 1;
      pointer-events: auto;
    }

    .detail-modal {
      width: min(480px, 90vw);
      max-height: min(70vh, 90vh);
      background: rgba(255,255,255,0.98);
      border-radius: 16px;
      box-shadow: 0 18px 45px rgba(0,0,0,0.22);
      padding: 20px 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      animation: pop-in 0.22s ease-out;
    }

    @keyframes pop-in {
      from {
        transform: translateY(6px) scale(0.96);
        opacity: 0;
      }
      to {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }

    .detail-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
    }
    .detail-title {
      font-size: 1.05rem;
      font-weight: 600;
    }
    .detail-tag {
      font-size: 0.8rem;
      color: #777;
      margin-top: 4px;
    }
    .detail-close {
      border: none;
      background: transparent;
      font-size: 1.3rem;
      line-height: 1;
      cursor: pointer;
      padding: 4px 6px;
      margin: -4px -4px 0 0;
    }
    .detail-body {
      font-size: 0.9rem;
      color: #444;
      line-height: 1.5;
      overflow-y: auto;
      padding-right: 4px;
    }
    .detail-meta {
      font-size: 0.78rem;
      color: #999;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="intro">
    어디든 한 번 탭/클릭하면 작업들이 우르르 떨어집니다.<br />
    도형을 드래그해서 움직이고, 톡 클릭하면 설명이 떠요.
  </div>

  <!-- 중앙 모달 오버레이 -->
  <div class="detail-overlay" id="detailOverlay">
    <div class="detail-modal">
      <div class="detail-header">
        <div>
          <div class="detail-title" id="detailTitle">작업 제목</div>
          <div class="detail-tag" id="detailTag">카테고리 / 연도</div>
        </div>
        <button class="detail-close" id="detailClose" aria-label="닫기">×</button>
      </div>
      <div class="detail-body" id="detailBody">
        여기에 작업 설명이 들어갑니다.
      </div>
      <div class="detail-meta" id="detailMeta"></div>
    </div>
  </div>

  <script>
    // ===== 캔버스 / 기본 세팅 =====
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const intro = document.getElementById('intro');

    const detailOverlay = document.getElementById('detailOverlay');
    const detailTitle = document.getElementById('detailTitle');
    const detailTag = document.getElementById('detailTag');
    const detailBody = document.getElementById('detailBody');
    const detailMeta = document.getElementById('detailMeta');
    const detailClose = document.getElementById('detailClose');

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // ===== 작업 데이터 (나중에 PNG 연결할 자리) =====
    const works = [
      {
        id: 'work-1',
        title: '포스터 시리즈 A',
        tag: 'Graphic / 2024',
        description: '굵은 타이포와 제한된 컬러 팔레트로 리듬을 만든 포스터 시리즈입니다.',
        meta: 'Size: 700×1000mm · Tool: Photoshop, Illustrator'
      },
      {
        id: 'work-2',
        title: '웹 인터랙션 실험',
        tag: 'Interactive / 2025',
        description: '스크롤과 물리 기반 움직임을 결합한 인터랙티브 웹 실험입니다.',
        meta: 'Prototype · HTML/CSS/JS'
      },
      {
        id: 'work-3',
        title: '브랜딩 콘셉트 B',
        tag: 'Branding / 2023',
        description: '소셜 이슈와 연결된 브랜드 톤앤매너를 시각 언어로 정리한 프로젝트입니다.',
        meta: 'Logo · Stationery · SNS kit'
      },
      {
        id: 'work-4',
        title: '에디토리얼 레이아웃',
        tag: 'Editorial / 2023',
        description: '텍스트 밀도가 높은 글을 읽기 쉽게 재배열한 에디토리얼 디자인입니다.',
        meta: '80p · InDesign, Typography'
      },
      {
        id: 'work-5',
        title: '동적 아이덴티티',
        tag: 'Motion / 2024',
        description: '로고와 모션 그래픽을 묶어 시스템 형태로 구성한 아이덴티티 실험입니다.',
        meta: 'Motion System · After Effects'
      }
    ];

    // ===== 도형(지금은 원) 배열 =====
    const shapes = [];
    let hasSpawned = false;

    function randomColor() {
      const palette = [
        '#f6a5c0',
        '#9ad0f5',
        '#f9dd8a',
        '#c3f0b8',
        '#d1b2ff',
        '#ffd6a5',
        '#bdb2ff',
        '#ffc6ff'
      ];
      return palette[Math.floor(Math.random() * palette.length)];
    }

    function spawnShapes() {
      const w = canvas.width;
      const h = canvas.height;
      shapes.length = 0;

      const count = 14; // 도형 개수

      for (let i = 0; i < count; i++) {
        const r = 40 + Math.random() * 25; // 40~65
        const x = r + Math.random() * (w - 2 * r);
        const y = -200 - Math.random() * 300; // 화면 위에서 떨어지게
        const vx = (Math.random() - 0.5) * 60;
        const vy = 0;

        const work = works[i % works.length];
        shapes.push({
          id: work.id,
          x,
          y,
          vx,
          vy,
          radius: r,
          color: randomColor(),
          work,
          isDragging: false
        });
      }
    }

    // ===== 물리 업데이트 =====
    const gravity = 800;      // px/s^2
    const damping = 0.8;      // 벽/바닥 감쇠
    const restitution = 0.5;  // 도형끼리 충돌 탄성
    let lastTime = null;

    function update(dt) {
      const w = canvas.width;
      const h = canvas.height;

      // 중력 + 위치 업데이트
      for (const s of shapes) {
        if (!s.isDragging) {
          s.vy += gravity * dt;
          s.x += s.vx * dt;
          s.y += s.vy * dt;
        } else {
          // 드래그 중엔 위치는 포인터가 직접 제어, 물리속도는 따로 처리 안 함
        }

        // 좌우 벽
        if (s.x - s.radius < 0) {
          s.x = s.radius;
          if (s.vx < 0) s.vx = -s.vx * damping;
        }
        if (s.x + s.radius > w) {
          s.x = w - s.radius;
          if (s.vx > 0) s.vx = -s.vx * damping;
        }

        // 바닥
        if (s.y + s.radius > h) {
          s.y = h - s.radius;
          if (s.vy > 0) s.vy = -s.vy * damping;
        }

        // 천장
        if (s.y - s.radius < 0) {
          s.y = s.radius;
          if (s.vy < 0) s.vy = -s.vy * damping;
        }
      }

      // 도형 간 충돌
      for (let i = 0; i < shapes.length; i++) {
        for (let j = i + 1; j < shapes.length; j++) {
          const a = shapes[i];
          const b = shapes[j];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const minDist = a.radius + b.radius;

          if (dist > 0 && dist < minDist) {
            const overlap = minDist - dist;
            const nx = dx / dist;
            const ny = dy / dist;

            // 드래그 중인 애는 위치 고정, 나머지만 밀기
            if (a.isDragging && !b.isDragging) {
              b.x += nx * overlap;
              b.y += ny * overlap;
              b.vx += nx * overlap * 5;
              b.vy += ny * overlap * 5;
              continue;
            }
            if (b.isDragging && !a.isDragging) {
              a.x -= nx * overlap;
              a.y -= ny * overlap;
              a.vx -= nx * overlap * 5;
              a.vy -= ny * overlap * 5;
              continue;
            }

            // 둘 다 자유 상태면 반반씩 밀고 탄성 충돌
            a.x -= nx * overlap * 0.5;
            a.y -= ny * overlap * 0.5;
            b.x += nx * overlap * 0.5;
            b.y += ny * overlap * 0.5;

            const relVx = b.vx - a.vx;
            const relVy = b.vy - a.vy;
            const relAlongNormal = relVx * nx + relVy * ny;

            if (relAlongNormal < 0) {
              const jImpulse = -(1 + restitution) * relAlongNormal / 2;
              const ix = jImpulse * nx;
              const iy = jImpulse * ny;

              a.vx -= ix;
              a.vy -= iy;
              b.vx += ix;
              b.vy += iy;

              a.vx *= damping;
              a.vy *= damping;
              b.vx *= damping;
              b.vy *= damping;
            }
          }
        }
      }
    }

    // ===== 렌더링 =====
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (const s of shapes) {
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
        ctx.fillStyle = s.color;
        ctx.fill();

        ctx.fillStyle = 'rgba(0,0,0,0.65)';
        ctx.font = '500 13px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(s.id.replace('work-', '#'), s.x, s.y);
      }
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = Math.min((timestamp - lastTime) / 1000, 0.03);
      lastTime = timestamp;

      if (shapes.length > 0) {
        update(dt);
        draw();
      } else {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ===== 상세 모달 =====
    function showDetail(work) {
      detailTitle.textContent = work.title;
      detailTag.textContent = work.tag;
      detailBody.textContent = work.description;
      detailMeta.textContent = work.meta || '';
      detailOverlay.classList.add('open');
    }
    function hideDetail() {
      detailOverlay.classList.remove('open');
    }

    detailClose.addEventListener('click', hideDetail);
    detailOverlay.addEventListener('click', (e) => {
      // 바깥(어두운 영역) 클릭 시 닫기
      if (e.target === detailOverlay) {
        hideDetail();
      }
    });

    // ===== 포인터(마우스 + 터치) 공통 상태 =====
    let isPointerDown = false;
    let dragTarget = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let lastPointerX = 0;
    let lastPointerY = 0;
    let pointerDownTime = 0;
    let pointerMovedDistSq = 0;

    // 드래그 관성 계산용: 최근 위치 히스토리
    let dragHistory = []; // {x, y, t}

    function getShapeAt(x, y) {
      for (let i = shapes.length - 1; i >= 0; i--) {
        const s = shapes[i];
        const dx = x - s.x;
        const dy = y - s.y;
        if (dx * dx + dy * dy <= s.radius * s.radius) {
          return s;
        }
      }
      return null;
    }

    function pointerDown(x, y) {
      isPointerDown = true;
      lastPointerX = x;
      lastPointerY = y;
      pointerDownTime = performance.now();
      pointerMovedDistSq = 0;
      dragHistory = [];

      const s = getShapeAt(x, y);
      if (s) {
        dragTarget = s;
        dragOffsetX = x - s.x;
        dragOffsetY = y - s.y;
        s.isDragging = true;
      } else {
        dragTarget = null;
      }
    }

    function pointerMove(x, y) {
      if (!isPointerDown || !dragTarget) return;

      const dx = x - lastPointerX;
      const dy = y - lastPointerY;

      pointerMovedDistSq += dx * dx + dy * dy;

      dragTarget.x = x - dragOffsetX;
      dragTarget.y = y - dragOffsetY;

      lastPointerX = x;
      lastPointerY = y;

      const now = performance.now();
      dragHistory.push({ x: dragTarget.x, y: dragTarget.y, t: now });
      if (dragHistory.length > 5) {
        dragHistory.shift(); // 최근 5개 샘플만 유지
      }
    }

    function pointerUp(x, y) {
      if (!isPointerDown) return;
      isPointerDown = false;

      const elapsed = performance.now() - pointerDownTime;
      const CLICK_DIST_SQ = 10 * 10;
      const CLICK_TIME = 300;

      let clickedShape = dragTarget || getShapeAt(x, y || lastPointerX, y || lastPointerY);

      // ★ 드래그 종료 시 관성(속도) 부여 ★
      if (dragTarget) {
        dragTarget.isDragging = false;
        if (dragHistory.length >= 2) {
          const a = dragHistory[dragHistory.length - 2];
          const b = dragHistory[dragHistory.length - 1];
          const dtMs = b.t - a.t;
          if (dtMs > 0) {
            const dt = dtMs / 1000;
            const vx = (b.x - a.x) / dt;
            const vy = (b.y - a.y) / dt;
            dragTarget.vx = vx * 0.9; // 살짝 감쇠해서 과하지 않게
            dragTarget.vy = vy * 0.9;
          }
        }
      }

      dragTarget = null;
      dragHistory = [];

      // 거의 안 움직이고 짧게 눌렀으면 클릭으로 처리
      if (clickedShape && pointerMovedDistSq <= CLICK_DIST_SQ && elapsed <= CLICK_TIME) {
        showDetail(clickedShape.work);
      }
    }

    // ===== 마우스 이벤트 =====
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      pointerDown(x, y);
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isPointerDown) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      pointerMove(x, y);
    });

    canvas.addEventListener('mouseup', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      pointerUp(x, y);
    });

    window.addEventListener('mouseup', () => {
      // 캔버스 밖에서 떨어져도 드래그 종료
      if (dragTarget) dragTarget.isDragging = false;
      isPointerDown = false;
      dragTarget = null;
      dragHistory = [];
    });

    // ===== 터치 이벤트 (모바일) =====
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      pointerDown(x, y);
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!isPointerDown) return;
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      pointerMove(x, y);
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      // touchend에는 좌표가 없을 수 있으니 마지막 좌표 사용
      pointerUp(lastPointerX, lastPointerY);
    }, { passive: false });

    canvas.addEventListener('touchcancel', (e) => {
      e.preventDefault();
      if (dragTarget) dragTarget.isDragging = false;
      isPointerDown = false;
      dragTarget = null;
      dragHistory = [];
    }, { passive: false });

    // ===== 첫 클릭/탭 시 도형 떨어뜨리기 =====
    function handleFirstActivate() {
      if (!hasSpawned) {
        hasSpawned = true;
        intro.classList.add('hidden');
        spawnShapes();
      }
    }

    document.body.addEventListener('click', function onceClick() {
      handleFirstActivate();
      document.body.removeEventListener('click', onceClick);
    }, { once: true });

    document.body.addEventListener('touchstart', function onceTouch() {
      handleFirstActivate();
      document.body.removeEventListener('touchstart', onceTouch);
    }, { once: true, passive: true });
  </script>
</body>
</html>
