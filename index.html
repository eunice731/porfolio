<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Portfolio Physics Wall</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #ffffff;
    }
    canvas {
      position: fixed; inset: 0; display: block;
      background: #ffffff; touch-action: none;
      /* 캔버스 크기는 스타일로 한번 더 잡아줘야 함 */
      width: 100%; height: 100%; 
    }
    #intro {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      pointer-events: none;
      font-size: 1.05rem; color: #999; text-align: center;
      padding: 0 16px; transition: opacity 0.3s ease;
      z-index: 5; line-height: 1.6;
    }
    #intro.hidden { opacity: 0; }

    /* 상세 모달 스타일 */
    .detail-overlay {
      position: fixed; inset: 0;
      display: flex; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.25);
      opacity: 0; pointer-events: none; transition: opacity 0.25s ease;
      z-index: 10;
    }
    .detail-overlay.open { opacity: 1; pointer-events: auto; }
    .detail-modal {
      width: min(480px, 80vw); max-height: min(70vh, 90vh);
      background: rgba(255,255,255,0.98); border-radius: 16px;
      box-shadow: 0 18px 45px rgba(0,0,0,0.22);
      padding: 20px 18px; display: flex; flex-direction: column; gap: 12px;
      animation: pop-in 0.22s ease-out;
    }
    @keyframes pop-in {
      from { transform: translateY(6px) scale(0.96); opacity: 0; }
      to { transform: translateY(0) scale(1); opacity: 1; }
    }
    .detail-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 8px; }
    .detail-title { font-size: 1.05rem; font-weight: 600; }
    .detail-tag { font-size: 0.8rem; color: #777; margin-top: 4px; }
    .detail-close {
      border: none; background: transparent; font-size: 1.3rem;
      line-height: 1; cursor: pointer; padding: 4px 6px; margin: -4px -4px 0 0;
    }
    .detail-body { font-size: 0.9rem; color: #444; line-height: 1.6; overflow-y: auto; padding-right: 4px; }
    .detail-meta { font-size: 0.78rem; color: #999; margin-top: 4px; }

    @media (max-width: 900px) {
      #intro { font-size: 1.3rem; padding: 0 28px; }
      .detail-modal { width: 94vw; max-height: 80vh; border-radius: 18px; padding: 22px 20px; }
      .detail-title { font-size: 1.35rem; }
      .detail-tag { font-size: 0.95rem; }
      .detail-body { font-size: 1.05rem; }
      .detail-meta { font-size: 0.9rem; }
      .detail-close { font-size: 1.6rem; }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="intro">이미지 로딩 중... 잠시만 기다려주세요.</div>

  <div class="detail-overlay" id="detailOverlay">
    <div class="detail-modal">
      <div class="detail-header">
        <div>
          <div class="detail-title" id="detailTitle"></div>
          <div class="detail-tag" id="detailTag"></div>
        </div>
        <button class="detail-close" id="detailClose">×</button>
      </div>
      <div class="detail-body" id="detailBody"></div>
      <div class="detail-meta" id="detailMeta"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const intro = document.getElementById('intro');
    
    // 모달 관련 요소
    const detailOverlay = document.getElementById('detailOverlay');
    const detailTitle = document.getElementById('detailTitle');
    const detailTag = document.getElementById('detailTag');
    const detailBody = document.getElementById('detailBody');
    const detailMeta = document.getElementById('detailMeta');
    const detailClose = document.getElementById('detailClose');

    // [핵심 수정 1] 고해상도(Retina) 디스플레이 대응 리사이징 함수
    function resize() {
      const dpr = window.devicePixelRatio || 1;
      // 캔버스의 '실제 픽셀 크기'를 키움
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      
      // 화면에 보이는 '스타일 크기'는 그대로 둠
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      
      // 그리기 좌표계를 확대 (이제 1을 그리면 dpr만큼 그려짐)
      ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', resize);
    resize();

    const isMobile = () => window.innerWidth <= 900;

    // ==========================================
    // ===== 작업 데이터 리스트 =====
    // ==========================================
    const works = [
      {
        id: 'work-1',
        title: '작업물 1',
        tag: 'Graphic / 2024',
        description: '작업물 1에 대한 설명입니다.',
        meta: 'Photoshop',
        imageSrc: './icon/1.png'
      },
      {
        id: 'work-2',
        title: '작업물 2',
        tag: 'Web / 2024',
        description: '작업물 2에 대한 설명입니다.',
        meta: 'HTML/CSS',
        imageSrc: './icon/2.png'
      },
      {
        id: 'work-3',
        title: '작업물 3',
        tag: 'Branding / 2023',
        description: '작업물 3에 대한 설명입니다.',
        meta: 'Illustrator',
        imageSrc: './icon/3.png'
      },
      {
        id: 'work-4',
        title: '작업물 4',
        tag: 'Editorial / 2023',
        description: '작업물 4 설명',
        meta: 'InDesign',
        imageSrc: './icon/4.png'
      },
      {
        id: 'work-5',
        title: '작업물 5',
        tag: 'Motion / 2024',
        description: '작업물 5에 대한 설명입니다.',
        meta: 'After Effects',
        imageSrc: './icon/5.png'
      },
      {
        id: 'work-6',
        title: '작업물 6',
        tag: 'UI/UX / 2024',
        description: '작업물 6에 대한 설명입니다.',
        meta: 'Figma',
        imageSrc: './icon/6.png'
      },
      {
        id: 'work-7',
        title: '작업물 7',
        tag: '3D / 2024',
        description: '작업물 7에 대한 설명입니다.',
        meta: 'Blender',
        imageSrc: './icon/7.png'
      },
      {
        id: 'work-8',
        title: '작업물 8',
        tag: 'Graphic / 2023',
        description: '작업물 8에 대한 설명입니다.',
        meta: 'Photoshop',
        imageSrc: './icon/8.png'
      },
      {
        id: 'work-9',
        title: '작업물 9',
        tag: 'Web / 2023',
        description: '작업물 9에 대한 설명입니다.',
        meta: 'Javascript',
        imageSrc: './icon/9.png'
      },
      {
        id: 'work-10',
        title: '작업물 10',
        tag: 'Photo / 2024',
        description: '작업물 10에 대한 설명입니다.',
        meta: 'Lightroom',
        imageSrc: './icon/10.png'
      },
      {
        id: 'work-11',
        title: '작업물 11',
        tag: 'Drawing / 2022',
        description: '작업물 11에 대한 설명입니다.',
        meta: 'Procreate',
        imageSrc: './icon/11.png'
      },
      {
        id: 'work-12',
        title: '작업물 12',
        tag: 'Package / 2023',
        description: '작업물 12에 대한 설명입니다.',
        meta: 'Illustrator',
        imageSrc: './icon/12.png'
      },
      {
        id: 'work-13',
        title: '작업물 13',
        tag: 'Video / 2024',
        description: '작업물 13에 대한 설명입니다.',
        meta: 'Premiere Pro',
        imageSrc: './icon/13.png'
      },
      {
        id: 'work-14',
        title: '작업물 14',
        tag: 'Poster / 2023',
        description: '작업물 14에 대한 설명입니다.',
        meta: 'Photoshop',
        imageSrc: './icon/14.png'
      },
      {
        id: 'work-15',
        title: '작업물 15',
        tag: 'Logo / 2022',
        description: '작업물 15에 대한 설명입니다.',
        meta: 'Illustrator',
        imageSrc: './icon/15.png'
      }
    ];

    // ===== 이미지 프리로드 =====
    const loadedImages = {};
    let imagesLoadedCount = 0;
    let allImagesLoaded = false;

    function preloadImages(callback) {
      if (works.length === 0) {
        callback(); 
        return;
      }
      works.forEach(work => {
        const img = new Image();
        img.onload = () => {
          imagesLoadedCount++;
          if (imagesLoadedCount === works.length) {
            allImagesLoaded = true;
            callback();
          }
        };
        img.onerror = () => {
          console.error(`이미지 로드 실패: ${work.imageSrc}`);
          imagesLoadedCount++;
          if (imagesLoadedCount === works.length) {
            allImagesLoaded = true;
            callback();
          }
        };
        img.src = work.imageSrc;
        loadedImages[work.id] = img;
      });
    }

    // ===== 물리 엔진 및 렌더링 =====
    const shapes = [];
    let hasSpawned = false;
    const gravity = 800;
    const damping = 0.8;
    const restitution = 0.5;
    let lastTime = null;

    function spawnShapes() {
      if (!allImagesLoaded) return;
      
      // [핵심 수정 2] 논리적 너비/높이를 사용 (canvas.width는 이제 너무 커짐)
      const w = window.innerWidth;
      const h = window.innerHeight;
      shapes.length = 0;

      const mobile = isMobile();
      const count = works.length; 
      
      const baseRadius = mobile ? 50 : 40;
      const radiusRange = mobile ? 30 : 25;

      for (let i = 0; i < count; i++) {
        const work = works[i % works.length];
        const r = baseRadius + Math.random() * radiusRange;
        const x = r + Math.random() * (w - 2 * r);
        const y = -200 - Math.random() * 300; 
        const vx = (Math.random() - 0.5) * (mobile ? 40 : 60);
        
        shapes.push({
          id: work.id,
          x, y, vx, vy: 0,
          radius: r,
          image: loadedImages[work.id],
          work,
          isDragging: false
        });
      }
    }

    function update(dt) {
      // [핵심 수정 3] 물리 계산은 논리적 좌표(window.innerWidth) 기준
      const w = window.innerWidth;
      const h = window.innerHeight;

      for (const s of shapes) {
        if (!s.isDragging) {
          s.vy += gravity * dt;
          s.x += s.vx * dt;
          s.y += s.vy * dt;
        }

        // 벽 충돌 (천장 막힘 제거됨)
        if (s.x - s.radius < 0) { s.x = s.radius; if(s.vx < 0) s.vx = -s.vx * damping; }
        if (s.x + s.radius > w) { s.x = w - s.radius; if(s.vx > 0) s.vx = -s.vx * damping; }
        if (s.y + s.radius > h) { s.y = h - s.radius; if(s.vy > 0) s.vy = -s.vy * damping; }
      }

      // 상호 충돌
      for (let i = 0; i < shapes.length; i++) {
        for (let j = i + 1; j < shapes.length; j++) {
          const a = shapes[i];
          const b = shapes[j];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          const minDist = a.radius + b.radius;

          if (dist > 0 && dist < minDist) {
            const overlap = minDist - dist;
            const nx = dx / dist;
            const ny = dy / dist;

            if (a.isDragging && !b.isDragging) {
              b.x += nx * overlap; b.y += ny * overlap;
              b.vx += nx * overlap*5; b.vy += ny * overlap*5;
              continue;
            }
            if (b.isDragging && !a.isDragging) {
              a.x -= nx * overlap; a.y -= ny * overlap;
              a.vx -= nx * overlap*5; a.vy -= ny * overlap*5;
              continue;
            }

            a.x -= nx * overlap * 0.5; a.y -= ny * overlap * 0.5;
            b.x += nx * overlap * 0.5; b.y += ny * overlap * 0.5;

            const relVx = b.vx - a.vx;
            const relVy = b.vy - a.vy;
            const relAlongNormal = relVx * nx + relVy * ny;

            if (relAlongNormal < 0) {
              const j = -(1 + restitution) * relAlongNormal / 2;
              const ix = j * nx; const iy = j * ny;
              a.vx -= ix; a.vy -= iy;
              b.vx += ix; b.vy += iy;
              a.vx *= damping; a.vy *= damping;
              b.vx *= damping; b.vy *= damping;
            }
          }
        }
      }
    }

    function draw() {
      // 캔버스 클리어 할 때도 논리적 크기 사용
      ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
      const mobile = isMobile();

      for (const s of shapes) {
        if (s.image && s.image.complete && s.image.naturalWidth !== 0) {
          ctx.drawImage(
            s.image,
            s.x - s.radius,
            s.y - s.radius,
            s.radius * 2,
            s.radius * 2
          );
        } else {
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.radius, 0, Math.PI*2);
          ctx.fillStyle = '#ccc';
          ctx.fill();
        }

        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.shadowColor = 'rgba(0,0,0,0.8)';
        ctx.shadowBlur = 4;
        ctx.font = mobile ? '700 20px system-ui' : '600 14px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(s.work.title, s.x, s.y); 
        
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
      }
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = Math.min((timestamp - lastTime) / 1000, 0.03);
      lastTime = timestamp;

      if (shapes.length > 0) {
        update(dt);
        draw();
      }
      requestAnimationFrame(loop);
    }

    // ===== 초기화 및 이벤트 =====
    function onImagesReady() {
      intro.innerHTML = '화면을 탭하면 아이콘들이 떨어집니다.<br>드래그하거나 클릭해보세요.';
      
      const start = () => {
        if (!hasSpawned) {
          hasSpawned = true;
          intro.classList.add('hidden');
          spawnShapes();
        }
      };
      document.body.addEventListener('click', start, { once: true });
      document.body.addEventListener('touchstart', start, { once: true, passive: true });
      
      requestAnimationFrame(loop);
    }

    preloadImages(onImagesReady);

    // ===== 모달 제어 =====
    function showDetail(work) {
      detailTitle.textContent = work.title;
      detailTag.textContent = work.tag;
      detailBody.textContent = work.description;
      detailMeta.textContent = work.meta;
      detailOverlay.classList.add('open');
    }
    function hideDetail() { detailOverlay.classList.remove('open'); }
    detailClose.addEventListener('click', hideDetail);
    detailOverlay.addEventListener('click', e => { if(e.target === detailOverlay) hideDetail(); });

    // ===== 포인터 로직 (드래그 & 클릭) =====
    let isPointerDown = false;
    let dragTarget = null;
    let dragOffsetX=0, dragOffsetY=0;
    let lastPointerX=0, lastPointerY=0;
    let pointerDownTime=0;
    let pointerMovedDistSq=0;
    let dragHistory = [];

    function getShapeAt(x, y) {
      for (let i = shapes.length - 1; i >= 0; i--) {
        const s = shapes[i];
        const dx = x - s.x;
        const dy = y - s.y;
        if (dx*dx + dy*dy <= s.radius * s.radius) return s;
      }
      return null;
    }

    function pointerDown(x, y) {
      isPointerDown = true;
      lastPointerX = x; lastPointerY = y;
      pointerDownTime = performance.now();
      pointerMovedDistSq = 0;
      dragHistory = [];

      const s = getShapeAt(x, y);
      if (s) {
        dragTarget = s;
        dragOffsetX = x - s.x;
        dragOffsetY = y - s.y;
        s.isDragging = true;
      }
    }

    function pointerMove(x, y) {
      if (!isPointerDown || !dragTarget) return;
      const dx = x - lastPointerX; const dy = y - lastPointerY;
      pointerMovedDistSq += dx*dx + dy*dy;
      dragTarget.x = x - dragOffsetX;
      dragTarget.y = y - dragOffsetY;
      lastPointerX = x; lastPointerY = y;
      
      dragHistory.push({ x: dragTarget.x, y: dragTarget.y, t: performance.now() });
      if (dragHistory.length > 5) dragHistory.shift();
    }

    function pointerUp(x, y) {
      if (!isPointerDown) return;
      isPointerDown = false;
      const elapsed = performance.now() - pointerDownTime;

      // 놓을 때 속도 부여
      if (dragTarget && dragHistory.length >= 2) {
        dragTarget.isDragging = false;
        const a = dragHistory[dragHistory.length - 2];
        const b = dragHistory[dragHistory.length - 1];
        const dt = (b.t - a.t) / 1000;
        if (dt > 0) {
          dragTarget.vx = (b.x - a.x) / dt * 0.9;
          dragTarget.vy = (b.y - a.y) / dt * 0.9;
        }
      }

      // 클릭 판정
      let clicked = dragTarget || getShapeAt(x, y);
      if (!dragTarget) clicked = getShapeAt(x, y); 
      
      if (clicked && pointerMovedDistSq < 100 && elapsed < 300) {
        showDetail(clicked.work);
      }
      dragTarget = null;
      dragHistory = [];
    }

    // 마우스/터치 리스너 연결
    ['mousedown','touchstart'].forEach(evt => 
      canvas.addEventListener(evt, e => {
        e.preventDefault();
        const r = canvas.getBoundingClientRect();
        const p = e.touches ? e.touches[0] : e;
        pointerDown(p.clientX - r.left, p.clientY - r.top);
      }, {passive:false})
    );
    ['mousemove','touchmove'].forEach(evt => 
      canvas.addEventListener(evt, e => {
        e.preventDefault();
        if(!isPointerDown) return;
        const r = canvas.getBoundingClientRect();
        const p = e.touches ? e.touches[0] : e;
        pointerMove(p.clientX - r.left, p.clientY - r.top);
      }, {passive:false})
    );
    ['mouseup','touchend','touchcancel'].forEach(evt => 
      canvas.addEventListener(evt, e => {
        e.preventDefault();
        pointerUp(lastPointerX, lastPointerY);
      }, {passive:false})
    );
  </script>
</body>
</html>
