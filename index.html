<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Portfolio Physics Wall (Simple)</title>
  <style>
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #ffffff;
    }
    canvas {
      position: fixed;
      inset: 0;
      display: block;
      background: #ffffff;
    }

    #intro {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      font-size: 1.1rem;
      color: #999;
      transition: opacity 0.3s ease;
    }
    #intro.hidden {
      opacity: 0;
    }

    .detail-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: min(360px, 80vw);
      height: 100%;
      background: rgba(255,255,255,0.98);
      box-shadow: -8px 0 20px rgba(0,0,0,0.08);
      padding: 24px 20px;
      transform: translateX(100%);
      transition: transform 0.3s ease;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 10;
    }
    .detail-panel.open {
      transform: translateX(0);
    }
    .detail-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    .detail-title {
      font-size: 1.1rem;
      font-weight: 600;
    }
    .detail-tag {
      font-size: 0.8rem;
      color: #777;
    }
    .detail-close {
      border: none;
      background: transparent;
      font-size: 1.3rem;
      line-height: 1;
      cursor: pointer;
      padding: 4px 6px;
    }
    .detail-body {
      font-size: 0.9rem;
      color: #444;
      line-height: 1.5;
      overflow-y: auto;
    }
    .detail-meta {
      font-size: 0.8rem;
      color: #999;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="intro">어디든 한 번 클릭하면 작업들이 우르르 떨어집니다. / 드래그 &amp; 클릭해 보세요.</div>

  <aside class="detail-panel" id="detailPanel">
    <div class="detail-header">
      <div>
        <div class="detail-title" id="detailTitle">작업 제목</div>
        <div class="detail-tag" id="detailTag">카테고리 / 연도</div>
      </div>
      <button class="detail-close" id="detailClose" aria-label="닫기">×</button>
    </div>
    <div class="detail-body" id="detailBody">
      여기에 작업 설명이 들어갑니다.
    </div>
    <div class="detail-meta" id="detailMeta"></div>
  </aside>

  <script>
    // ===== 캔버스 / 기본 세팅 =====
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const intro = document.getElementById('intro');
    const detailPanel = document.getElementById('detailPanel');
    const detailTitle = document.getElementById('detailTitle');
    const detailTag = document.getElementById('detailTag');
    const detailBody = document.getElementById('detailBody');
    const detailMeta = document.getElementById('detailMeta');
    const detailClose = document.getElementById('detailClose');

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // ===== 작업 데이터 (나중에 PNG 연결할 자리) =====
    const works = [
      {
        id: 'work-1',
        title: '포스터 시리즈 A',
        tag: 'Graphic / 2024',
        description: '굵은 타이포와 제한된 컬러 팔레트로 리듬을 만든 포스터 시리즈입니다.',
        meta: 'Size: 700×1000mm · Tool: Photoshop, Illustrator'
      },
      {
        id: 'work-2',
        title: '웹 인터랙션 실험',
        tag: 'Interactive / 2025',
        description: '스크롤과 물리 기반 움직임을 결합한 인터랙티브 웹 실험입니다.',
        meta: 'Prototype · HTML/CSS/JS'
      },
      {
        id: 'work-3',
        title: '브랜딩 콘셉트 B',
        tag: 'Branding / 2023',
        description: '소셜 이슈와 연결된 브랜드 톤앤매너를 시각 언어로 정리한 프로젝트입니다.',
        meta: 'Logo · Stationery · SNS kit'
      },
      {
        id: 'work-4',
        title: '에디토리얼 레이아웃',
        tag: 'Editorial / 2023',
        description: '텍스트 밀도가 높은 글을 읽기 쉽게 재배열한 에디토리얼 디자인입니다.',
        meta: '80p · InDesign, Typography'
      },
      {
        id: 'work-5',
        title: '동적 아이덴티티',
        tag: 'Motion / 2024',
        description: '로고와 모션 그래픽을 묶어 시스템 형태로 구성한 아이덴티티 실험입니다.',
        meta: 'Motion System · After Effects'
      }
    ];

    // ===== 도형(지금은 원) 배열 =====
    const shapes = [];
    let hasSpawned = false;

    function randomColor() {
      const palette = [
        '#f6a5c0',
        '#9ad0f5',
        '#f9dd8a',
        '#c3f0b8',
        '#d1b2ff',
        '#ffd6a5',
        '#bdb2ff',
        '#ffc6ff'
      ];
      return palette[Math.floor(Math.random() * palette.length)];
    }

    function spawnShapes() {
      const w = canvas.width;
      const h = canvas.height;
      shapes.length = 0;

      const count = 14; // 도형 개수

      for (let i = 0; i < count; i++) {
        const r = 40 + Math.random() * 25; // 40~65
        const x = r + Math.random() * (w - 2 * r);
        const y = -200 - Math.random() * 300; // 화면 위에서 떨어지게
        const vx = (Math.random() - 0.5) * 100;
        const vy = 0;

        const work = works[i % works.length]; // 그냥 순환해서 연결
        shapes.push({
          id: work.id,
          x,
          y,
          vx,
          vy,
          radius: r,
          color: randomColor(),
          work: work
        });
      }
    }

    // ===== 물리 업데이트 =====
    const gravity = 900; // px/s^2
    const damping = 0.75; // 충돌 감쇠
    let lastTime = null;

    function update(dt) {
      const w = canvas.width;
      const h = canvas.height;

      // 중력 + 위치 업데이트
      for (const s of shapes) {
        s.vy += gravity * dt;
        s.x += s.vx * dt;
        s.y += s.vy * dt;

        // 벽 충돌
        if (s.x - s.radius < 0) {
          s.x = s.radius;
          s.vx = Math.abs(s.vx) * damping;
        }
        if (s.x + s.radius > w) {
          s.x = w - s.radius;
          s.vx = -Math.abs(s.vx) * damping;
        }
        if (s.y + s.radius > h) {
          s.y = h - s.radius;
          s.vy = -Math.abs(s.vy) * damping;
        }
      }

      // 도형 간 충돌 (간단 버전, 원끼리)
      for (let i = 0; i < shapes.length; i++) {
        for (let j = i + 1; j < shapes.length; j++) {
          const a = shapes[i];
          const b = shapes[j];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const minDist = a.radius + b.radius;

          if (dist > 0 && dist < minDist) {
            const overlap = minDist - dist;

            const nx = dx / dist;
            const ny = dy / dist;

            // 포지션 분리 (반반씩 밀기)
            a.x -= nx * overlap * 0.5;
            a.y -= ny * overlap * 0.5;
            b.x += nx * overlap * 0.5;
            b.y += ny * overlap * 0.5;

            // 속도 교환 비슷하게 (간단한 탄성 충돌 느낌)
            const relVx = b.vx - a.vx;
            const relVy = b.vy - a.vy;
            const relAlongNormal = relVx * nx + relVy * ny;

            if (relAlongNormal < 0) {
              const impulse = -(1.0) * relAlongNormal; // 탄성계수 ≈ 1
              const ix = impulse * nx;
              const iy = impulse * ny;

              a.vx -= ix * 0.5;
              a.vy -= iy * 0.5;
              b.vx += ix * 0.5;
              b.vy += iy * 0.5;

              a.vx *= damping;
              a.vy *= damping;
              b.vx *= damping;
              b.vy *= damping;
            }
          }
        }
      }
    }

    // ===== 렌더링 =====
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (const s of shapes) {
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
        ctx.fillStyle = s.color;
        ctx.fill();

        // 간단한 텍스트 라벨 (작업 번호 느낌)
        ctx.fillStyle = 'rgba(0,0,0,0.65)';
        ctx.font = '500 13px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(s.id.replace('work-', '#'), s.x, s.y);
      }
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = Math.min((timestamp - lastTime) / 1000, 0.03); // 30ms 이상은 컷
      lastTime = timestamp;

      if (shapes.length > 0) {
        update(dt);
        draw();
      } else {
        // 아무것도 없으면 그냥 흰 화면 유지
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ===== 상세 패널 =====
    function showDetail(work) {
      detailTitle.textContent = work.title;
      detailTag.textContent = work.tag;
      detailBody.textContent = work.description;
      detailMeta.textContent = work.meta || '';
      detailPanel.classList.add('open');
    }
    function hideDetail() {
      detailPanel.classList.remove('open');
    }
    detailClose.addEventListener('click', hideDetail);

    // ===== 마우스 / 드래그 & 클릭 구분 =====
    let isMouseDown = false;
    let dragTarget = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let mouseDownTime = 0;
    let mouseMovedDistSq = 0;

    function getShapeAt(x, y) {
      // 위에 있는 것부터 잡고 싶으면 뒤에서부터 검사
      for (let i = shapes.length - 1; i >= 0; i--) {
        const s = shapes[i];
        const dx = x - s.x;
        const dy = y - s.y;
        if (dx * dx + dy * dy <= s.radius * s.radius) {
          return s;
        }
      }
      return null;
    }

    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      isMouseDown = true;
      lastMouseX = x;
      lastMouseY = y;
      mouseDownTime = performance.now();
      mouseMovedDistSq = 0;

      const s = getShapeAt(x, y);
      if (s) {
        dragTarget = s;
        dragOffsetX = x - s.x;
        dragOffsetY = y - s.y;
      } else {
        dragTarget = null;
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isMouseDown || !dragTarget) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const dx = x - lastMouseX;
      const dy = y - lastMouseY;

      mouseMovedDistSq += dx * dx + dy * dy;

      // 드래그 중인 도형 위치 이동
      const oldX = dragTarget.x;
      const oldY = dragTarget.y;
      dragTarget.x = x - dragOffsetX;
      dragTarget.y = y - dragOffsetY;

      // 움직이는 방향으로 속도 부여 (놓았을 때 관성)
      dragTarget.vx = (dragTarget.x - oldX) * 60; // 대략적인 스케일
      dragTarget.vy = (dragTarget.y - oldY) * 60;

      lastMouseX = x;
      lastMouseY = y;
    });

    canvas.addEventListener('mouseup', (e) => {
      if (!isMouseDown) return;
      isMouseDown = false;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const elapsed = performance.now() - mouseDownTime;
      const CLICK_DIST_SQ = 10 * 10; // 10px 이하 움직임이면 클릭으로 간주
      const CLICK_TIME = 300;        // 300ms 안이면 클릭

      const clickedShape = dragTarget || getShapeAt(x, y);

      // 드래그 종료
      dragTarget = null;

      // “거의 안 움직였고, 빠르게 눌렀다 떼면” → 클릭으로 처리
      if (clickedShape && mouseMovedDistSq <= CLICK_DIST_SQ && elapsed <= CLICK_TIME) {
        showDetail(clickedShape.work);
      }
    });

    // 드래그 중 캔버스 밖으로 나갔다가 들어오는 케이스 방지
    window.addEventListener('mouseup', () => {
      isMouseDown = false;
      dragTarget = null;
    });

    // ===== 첫 클릭 시 도형 떨어뜨리기 =====
    document.body.addEventListener('click', function handleFirstClick() {
      if (!hasSpawned) {
        hasSpawned = true;
        intro.classList.add('hidden');
        spawnShapes();
      }
      // 이후부터는 이 핸들러 필요 없으니 제거
      document.body.removeEventListener('click', handleFirstClick);
    }, { once: true });
  </script>
</body>
</html>
